# homework5

## 1. Почему в большинстве ситуаций стоит использовать flexbox-позиционирование?
Это один из основных современных способов позиционирования (вместе с CSS-grid). Да, в нем есть некоторые недостатки (например, он не поддерживается многими старыми версиями браузеров), но достоинств больше. Если его правильно использовать, можно верстать более сложныее макеты меньшим количеством кода. Плюс он хорош способностью изменять ширину или высоту дочерних элементов. Это позволяет легче заполнять доступные области на экранах разной ширины. Следовательно, с его помощью проще сделать адаптивный дизайн.

## 2. Самостоятельно изучите способ позиционирования через `display: table`  и ответьте на вопрос, для каких ситуаций оно лучше всего подходит? 

По сути свойство `display: table` это CSS-аналог HTML-тега <table> (т.е. имитирует его поведение) и может использоваться для создания таблиц. Но на практике зачастую использовалось для иных целей, в частности:
- для динамического выравнивания по центру (вертикальное и горизонтальное);
- разметки "Holy Grail".
Но статьи с применением `display: table` попадаются старые (2014 г., например). В новых материалах все больше информации, что "table" только для таблиц, остального проще и лучше добиваться иными способами позиционирования.

## 3. Какими способами можно сделать горизонтальное выравнивание по центру? Минимум 3 варианта, можно больше
1. display: block и margin: auto, если у блока есть ширина;
2. через абсолютное позиционирование. У родителя должно быть position: relative; у того элемента, что выравниваем по центру: position: absolute; top:50% и transform:translate(-50%, 0);
3. через flexbox: display: flex; justify-content: center;
4. через grid (задаем area и по ней justify-self: center);
5. если элемент строковый, можно через text-align: center.

## 4. Какие есть оси во флекс-верстке и как задается их направление?
Выделяют главную (идет слева-направо) и поперечную (сверху-вниз) оси. Направление по умолчанию названо в скобках, чтобы его изменить используют flex-direction или flex-flow (если надо еще и задать значения переноса (flex-wrap))

## 5. Разберитесь, как работает свойство `margin: auto` во флекс-верстке, приведите пример использования
Инфа прочитана. Наиболее распространенный способ использования - для центрирования элементов по горизонтали. Такая центровка будет сохраняться и при изменении размеров элемента (контейнера)

## 6. В чем преимущества `box-sizing`?
Он позволяет переопределить установленные размеры элементов. Это свойство позволяет влиять на то, как вычисляются размеры элемента. Например, при border-box при указании ширины и высоты элемента, его паддингов и бордеров. Конечной шириной элемента будет ширина, указанная верстальщиком (бордеры и падинги не добавляются к ней, а вычитаются из нее). Марджины при этом расчете не учитываются.

## 7. Чем отличается `flex-grow` от `flex-shrink`?
`flex-grow` показывает, будет ли ширина flex-элемента расти при наличии свободного пространства (если > 0 - будет). А `flex-shrink` - будет ли flex-элемент сжиматься, если ширина линии будет слишком мала, чтобы вместить все flex-элементы.

## 8. Как можно добиться следующего позиционирования элементов (см.фото)
Есть нюанс. На картинке слева от красного квадрата есть свободное пространство, у фиолетового справа тоже есть, но раз в пять меньше + полоска серая сверху есть только со стороны красного квадрата. Отсюда вывод: 1) или задание с подвохом, 2) или с погрешностью картинка. Если рассматривать ее, не обращая внимание на неравные отступы, я бы предложила такой вариант задать контейнеру  display: flex и  justify-content: space-between.

## 9. Какой в итоге будет размер у элемента (можно округлить)? 
Хотелось бы просто все ссумировать, посчитать и прийти к такому результату (т.к. box-sizing на рисунке нет, по умолчанию считаем content-box, модель аддитивна): 148,523 х 17,807. Но установлен flex-grow = 1. При этом flex-shrink и flex-basis не показаны на рисунке (по умолчанию считаем 1 и auto соответственно). Если элементу задано свойство flex, то конечный размер будет зависить от того, будет ли свободное пространство (как отрицательное, так и положительное), наличия иных элементов (их размеров, количества). Тут сомнение: на что указывает "в итоге" в вопросе?

## 10. Самостоятельно разберитесь, зачем нужно свойство `order`?
Его используют, чтобы изменить порядок следования flex-элементов.

## 11. Каким кодом можно сделать такую таблицу?
Например, так:
html
<table class="table">
    <tbody>
      <tr>
        <td class="title">Column 1</td>
        <td class="title">Column 2</td>
        <td class="title">Column 3</td>
      </tr>
      <tr>
        <td rowspan="2" class="item">Row 1 Cell 1</td>
        <td class="item">Row 1 Cell 2</td>
        <td class="item">Row 1 Cell 3</td>
      </tr>
      <tr>
        <td class="item">Row 2 Cell 2</td>
        <td class="item">Row 2 Cell 3</td>
      </tr>
      <tr>
        <td colspan="3" class="item">Row 3 Cell 1</td>
      </tr>
    </tbody>
  </table>

css
.table,
.item,
.title {
  border: 1px solid black;  
}

.item,
.title {
  padding: 4px 8px;
}

.title {
  text-align: center;
}

Прим. В референсе в первой строке Columu, изменила на Column

## 12. Изучите материалы и найдите, для каких ситуаций подходит `position: fixed`?
Это подвид абсолютного позиционирования, часто используется для фиксации при прокрутке навигации в хедере, кнопки "Вверх" в правом нижнем углу. В целом подходит для ситуации, когда надо зафиксировать какой-то элемент относительно window

## 13. Каким способом лучше всего верстать большие блоки текста?
По информации из материалов точно не через flexbox. Есть также фрагмент: "Блочные элементы, как правило, используются для больших кусков контента, таких как заголовки и структурные элементы. Строчные элементы, как правило, применяются для маленьких частей содержимого без переноса". Из этой информации делаю вывод: большие блоки текста верстаем блочной моделью.

## 14. Как рассчитывается размер flex-контейнера?
Я сломала голову над этим вопросом. Прямого ответа найти не смогла. Буду рассуждать сначала. Flex-контейнер - родительский html-элемент, которому задано свойство display: flex (inline-flex). При этом дети (так называемые flex-элементы) становятся гибкими и выстраиваются в один ряд. Размер flex-элементов зависит от свойств flex-grow, flex-shrink и flex-basis. При этом, полагаю, можно сказать, что размер flex-контейнера зависит от размеров flex-элементов, а также свойст самого flex-контейнера (flex-direction, flex-wrap и т.д.). Очень инетересен "академический" ответ на этот вопрос)))



